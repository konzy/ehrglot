// Package rust generates Rust code from schemas.
package rust

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/konzy/ehrglot/pkg/schema"
)

const Version = "0.1.0"

// Generator generates Rust code from schemas.
type Generator struct{}

// NewGenerator creates a new Rust code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates Rust structs from schemas.
func (g *Generator) Generate(schemas []schema.Schema, outputDir string) error {
	// Group schemas by namespace
	byNamespace := make(map[string][]schema.Schema)
	for _, s := range schemas {
		byNamespace[s.Namespace] = append(byNamespace[s.Namespace], s)
	}

	for namespace, nsSchemas := range byNamespace {
		nsDir := filepath.Join(outputDir, namespace)
		if err := os.MkdirAll(nsDir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}

		// Generate mod.rs with all types
		modPath := filepath.Join(nsDir, "mod.rs")
		if err := g.generateMod(nsSchemas, modPath); err != nil {
			return err
		}

		// Generate each schema file
		for _, s := range nsSchemas {
			filename := toSnakeCase(s.GetName()) + ".rs"
			path := filepath.Join(nsDir, filename)
			if err := g.generateStruct(s, path); err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) generateMod(schemas []schema.Schema, path string) error {
	tmpl := `//! Generated by ehrglot v` + Version + ` at ` + time.Now().Format(time.RFC3339) + `.
//! DO NOT EDIT.

{{range .}}mod {{. | schemaName | snake}};
pub use {{. | schemaName | snake}}::{{. | schemaName}};
{{end}}
`
	funcMap := template.FuncMap{
		"snake":      toSnakeCase,
		"schemaName": func(s schema.Schema) string { return s.GetName() },
	}

	tmpl_parsed, err := template.New("").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	return tmpl_parsed.Execute(f, schemas)
}

func (g *Generator) generateStruct(s schema.Schema, path string) error {
	tmpl := `//! {{.Schema.Description}}
//!
//! Generated by ehrglot v` + Version + ` at ` + time.Now().Format(time.RFC3339) + `.
//! DO NOT EDIT.

use serde::{Deserialize, Serialize};
use chrono::{NaiveDate, DateTime, Utc};

/// {{.Schema.Description}}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{.Schema | schemaName}} {
{{range .Schema.Fields}}    {{if not .Required}}#[serde(skip_serializing_if = "Option::is_none")]
    {{end}}pub {{.Name | snake}}: {{. | rustType}},
{{end}}}
`
	funcMap := template.FuncMap{
		"snake":      toSnakeCase,
		"rustType":   toRustTypeFromField,
		"schemaName": func(s schema.Schema) string { return s.GetName() },
	}

	tmpl_parsed, err := template.New("").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	data := struct {
		Schema schema.Schema
	}{Schema: s}

	return tmpl_parsed.Execute(f, data)
}

// GenerateMappings generates Rust mapper functions.
func (g *Generator) GenerateMappings(mappings []schema.SchemaMapping, outputDir string) error {
	// TODO: Implement mapping generation
	return nil
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func toRustTypeFromField(f schema.Field) string {
	return toRustType(f.Type, f.Required)
}

func toRustType(yamlType string, required bool) string {
	baseType := ""
	switch yamlType {
	case "string", "code", "id", "uri", "url":
		baseType = "String"
	case "integer", "positiveInt", "unsignedInt":
		baseType = "i64"
	case "decimal":
		baseType = "f64"
	case "boolean":
		baseType = "bool"
	case "date":
		baseType = "NaiveDate"
	case "datetime", "instant":
		baseType = "DateTime<Utc>"
	case "base64Binary":
		baseType = "Vec<u8>"
	default:
		if strings.HasPrefix(yamlType, "[]") {
			innerType := strings.TrimPrefix(yamlType, "[]")
			inner := toRustType(innerType, true) // inner types are always required in Vec
			baseType = fmt.Sprintf("Vec<%s>", inner)
		} else {
			baseType = "serde_json::Value"
		}
	}

	if required {
		return baseType
	}
	return fmt.Sprintf("Option<%s>", baseType)
}
