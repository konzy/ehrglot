// Package sql generates SQL/dbt code from schemas.
package sql

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/konzy/ehrglot/pkg/schema"
)

const Version = "0.1.0"

// Generator generates SQL/dbt code from schemas.
type Generator struct{}

// NewGenerator creates a new SQL code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates SQL DDL and dbt models from schemas.
func (g *Generator) Generate(schemas []schema.Schema, outputDir string) error {
	// Group schemas by namespace
	byNamespace := make(map[string][]schema.Schema)
	for _, s := range schemas {
		byNamespace[s.Namespace] = append(byNamespace[s.Namespace], s)
	}

	for namespace, nsSchemas := range byNamespace {
		// Create DDL directory
		ddlDir := filepath.Join(outputDir, namespace, "ddl")
		if err := os.MkdirAll(ddlDir, 0755); err != nil {
			return fmt.Errorf("failed to create DDL directory: %w", err)
		}

		// Create dbt models directory
		dbtDir := filepath.Join(outputDir, namespace, "dbt")
		if err := os.MkdirAll(dbtDir, 0755); err != nil {
			return fmt.Errorf("failed to create dbt directory: %w", err)
		}

		// Generate each schema
		for _, s := range nsSchemas {
			// Generate DDL
			ddlPath := filepath.Join(ddlDir, toSnakeCase(s.GetName())+".sql")
			if err := g.generateDDL(s, namespace, ddlPath); err != nil {
				return err
			}

			// Generate dbt model
			dbtPath := filepath.Join(dbtDir, "stg_"+toSnakeCase(s.GetName())+".sql")
			if err := g.generateDbtModel(s, namespace, dbtPath); err != nil {
				return err
			}
		}

		// Generate dbt schema.yml
		schemaPath := filepath.Join(dbtDir, "schema.yml")
		if err := g.generateDbtSchema(nsSchemas, namespace, schemaPath); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateDDL(s schema.Schema, namespace string, path string) error {
	tmpl := `-- {{.Schema.Description}}
--
-- Generated by ehrglot v` + Version + ` at ` + time.Now().Format(time.RFC3339) + `.
-- DO NOT EDIT.

CREATE TABLE IF NOT EXISTS {{.Schema | schemaName | snake}} (
{{range $i, $f := .Schema.Fields}}{{if $i}},
{{end}}    {{$f.Name | snake}} {{$f | sqlType}}{{if $f.Required}} NOT NULL{{end}}{{end}}
);

-- Add comments
COMMENT ON TABLE {{.Schema | schemaName | snake}} IS '{{.Schema.Description | escape}}';
{{range .Schema.Fields}}COMMENT ON COLUMN {{$.Schema | schemaName | snake}}.{{.Name | snake}} IS '{{.Description | escape}}';
{{end}}
`
	return g.executeTemplate(tmpl, s, namespace, path)
}

func (g *Generator) generateDbtModel(s schema.Schema, namespace string, path string) error {
	tmpl := `{#
  {{.Schema.Description}}

  Generated by ehrglot v` + Version + ` at ` + time.Now().Format(time.RFC3339) + `.
  DO NOT EDIT.
#}

{{ "{{" }} config(
    materialized='view',
    schema='{{.Namespace | snake}}'
) {{ "}}" }}

SELECT
{{range $i, $f := .Schema.Fields}}{{if $i}},
{{end}}    {{$f.Name | snake}}{{end}}
FROM {{ "{{" }} source('{{.Namespace | snake}}', '{{.Schema | schemaName | snake}}') {{ "}}" }}
`
	return g.executeTemplate(tmpl, s, namespace, path)
}

func (g *Generator) generateDbtSchema(schemas []schema.Schema, namespace string, path string) error {
	tmpl := `# Generated by ehrglot v` + Version + ` at ` + time.Now().Format(time.RFC3339) + `.
# DO NOT EDIT.

version: 2

sources:
  - name: {{.Namespace | snake}}
    tables:
{{range .Schemas}}      - name: {{. | schemaName | snake}}
        description: "{{.Description | escape}}"
        columns:
{{range .Fields}}          - name: {{.Name | snake}}
            description: "{{.Description | escape}}"
{{if .Required}}            tests:
              - not_null
{{end}}{{end}}{{end}}

models:
{{range .Schemas}}  - name: stg_{{. | schemaName | snake}}
    description: "Staging model for {{. | schemaName}}"
    columns:
{{range .Fields}}      - name: {{.Name | snake}}
        description: "{{.Description | escape}}"
{{end}}{{end}}
`
	funcMap := template.FuncMap{
		"snake":      toSnakeCase,
		"escape":     escapeYaml,
		"schemaName": func(s schema.Schema) string { return s.GetName() },
	}

	tmpl_parsed, err := template.New("").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	data := struct {
		Namespace string
		Schemas   []schema.Schema
	}{
		Namespace: namespace,
		Schemas:   schemas,
	}

	return tmpl_parsed.Execute(f, data)
}

func (g *Generator) executeTemplate(tmplStr string, s schema.Schema, namespace string, path string) error {
	funcMap := template.FuncMap{
		"snake":      toSnakeCase,
		"sqlType":    toSQLType,
		"escape":     escapeYaml,
		"schemaName": func(s schema.Schema) string { return s.GetName() },
	}

	tmpl_parsed, err := template.New("").Funcs(funcMap).Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	data := struct {
		Schema    schema.Schema
		Namespace string
	}{
		Schema:    s,
		Namespace: namespace,
	}

	return tmpl_parsed.Execute(f, data)
}

// GenerateMappings generates SQL/dbt mapper functions.
func (g *Generator) GenerateMappings(mappings []schema.SchemaMapping, outputDir string) error {
	return nil
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func escapeYaml(s string) string {
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}

func toSQLType(f schema.Field) string {
	switch f.Type {
	case "string", "code", "id", "uri", "url":
		return "VARCHAR(255)"
	case "integer", "positiveInt", "unsignedInt":
		return "INTEGER"
	case "decimal":
		return "DECIMAL(18, 6)"
	case "boolean":
		return "BOOLEAN"
	case "date":
		return "DATE"
	case "datetime", "instant":
		return "TIMESTAMP"
	case "base64Binary":
		return "BYTEA"
	default:
		if strings.HasPrefix(f.Type, "[]") {
			return "JSONB" // Arrays stored as JSON
		}
		return "JSONB" // Complex types as JSON
	}
}
