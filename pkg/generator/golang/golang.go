// Package golang generates Go code from schemas.
package golang

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/konzy/ehrglot/pkg/schema"
)

// Generator generates Go code from schemas.
type Generator struct{}

// NewGenerator creates a new Go code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates Go structs from schemas.
func (g *Generator) Generate(schemas []schema.Schema, outputDir string) error {
	// Group schemas by namespace
	byNamespace := make(map[string][]schema.Schema)
	for _, s := range schemas {
		byNamespace[s.Namespace] = append(byNamespace[s.Namespace], s)
	}

	for namespace, nsSchemas := range byNamespace {
		nsDir := filepath.Join(outputDir, namespace)
		if err := os.MkdirAll(nsDir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}

		// Generate package file with all types
		path := filepath.Join(nsDir, "types.go")
		if err := g.generateTypes(namespace, nsSchemas, path); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateTypes(namespace string, schemas []schema.Schema, path string) error {
	tmpl := `// Code generated by ehrglot. DO NOT EDIT.
package {{.Namespace}}

import (
	"time"
)

{{range .Schemas}}
// {{.Name}} - {{.Description}}
type {{.Name}} struct {
{{range .Fields}}	{{.Name | pascal}}	{{.Type | goType}}	` + "`json:\"{{.Name | lower}}{{if not .Required}},omitempty{{end}}\"`" + `{{if .Description}} // {{.Description}}{{end}}
{{end}}}
{{end}}
`
	funcMap := template.FuncMap{
		"lower":  strings.ToLower,
		"pascal": toPascalCase,
		"goType": toGoType,
	}

	tmpl_parsed, err := template.New("").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	data := struct {
		Namespace string
		Schemas   []schema.Schema
	}{
		Namespace: strings.ReplaceAll(namespace, "-", "_"),
		Schemas:   schemas,
	}

	return tmpl_parsed.Execute(f, data)
}

// GenerateMappings generates Go mapper functions.
func (g *Generator) GenerateMappings(mappings []schema.SchemaMapping, outputDir string) error {
	// TODO: Implement mapping generation
	return nil
}

func toPascalCase(s string) string {
	words := strings.Split(s, "_")
	for i, w := range words {
		if len(w) > 0 {
			words[i] = strings.ToUpper(w[:1]) + w[1:]
		}
	}
	return strings.Join(words, "")
}

func toGoType(yamlType string) string {
	switch yamlType {
	case "string", "code", "id", "uri", "url":
		return "string"
	case "integer", "positiveInt", "unsignedInt":
		return "int"
	case "decimal":
		return "float64"
	case "boolean":
		return "bool"
	case "date", "datetime", "instant":
		return "*time.Time"
	case "base64Binary":
		return "[]byte"
	default:
		if strings.HasPrefix(yamlType, "[]") {
			innerType := strings.TrimPrefix(yamlType, "[]")
			return fmt.Sprintf("[]%s", toGoType(innerType))
		}
		return "interface{}"
	}
}
