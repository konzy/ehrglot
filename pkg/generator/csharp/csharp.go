// Package csharp generates C# code from schemas.
package csharp

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/konzy/ehrglot/pkg/schema"
)

const Version = "0.1.0"

// Generator generates C# code from schemas.
type Generator struct{}

// NewGenerator creates a new C# code generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates C# classes from schemas.
func (g *Generator) Generate(schemas []schema.Schema, outputDir string) error {
	// Group schemas by namespace
	byNamespace := make(map[string][]schema.Schema)
	for _, s := range schemas {
		byNamespace[s.Namespace] = append(byNamespace[s.Namespace], s)
	}

	for namespace, nsSchemas := range byNamespace {
		nsDir := filepath.Join(outputDir, namespace)
		if err := os.MkdirAll(nsDir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}

		// Generate each schema file
		for _, s := range nsSchemas {
			filename := s.GetName() + ".cs"
			path := filepath.Join(nsDir, filename)
			if err := g.generateClass(s, namespace, path); err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) generateClass(s schema.Schema, namespace string, path string) error {
	tmpl := `// {{.Schema.Description}}
//
// Generated by ehrglot v` + Version + ` at ` + time.Now().Format(time.RFC3339) + `.
// DO NOT EDIT.

using System;
using System.Text.Json.Serialization;

namespace {{.Namespace}}
{
    /// <summary>
    /// {{.Schema.Description}}
    /// </summary>
    public class {{.Schema | schemaName}}
    {
{{range .Schema.Fields}}        [JsonPropertyName("{{.Name | camel}}")]
        public {{. | csharpType}} {{.Name | pascal}} { get; set; }

{{end}}    }
}
`
	funcMap := template.FuncMap{
		"camel":      toCamelCase,
		"pascal":     toPascalCase,
		"csharpType": toCSharpType,
		"schemaName": func(s schema.Schema) string { return s.GetName() },
	}

	tmpl_parsed, err := template.New("").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	// Convert namespace to C# namespace (PascalCase)
	csharpNamespace := toPascalCase(strings.ReplaceAll(namespace, "_", "."))

	data := struct {
		Schema    schema.Schema
		Namespace string
	}{
		Schema:    s,
		Namespace: csharpNamespace,
	}

	return tmpl_parsed.Execute(f, data)
}

// GenerateMappings generates C# mapper functions.
func (g *Generator) GenerateMappings(mappings []schema.SchemaMapping, outputDir string) error {
	return nil
}

func toCamelCase(s string) string {
	words := strings.Split(s, "_")
	for i, w := range words {
		if i == 0 {
			words[i] = strings.ToLower(w)
		} else if len(w) > 0 {
			words[i] = strings.ToUpper(w[:1]) + strings.ToLower(w[1:])
		}
	}
	return strings.Join(words, "")
}

func toPascalCase(s string) string {
	words := strings.Split(s, "_")
	for i, w := range words {
		if len(w) > 0 {
			words[i] = strings.ToUpper(w[:1]) + strings.ToLower(w[1:])
		}
	}
	return strings.Join(words, "")
}

func toCSharpType(f schema.Field) string {
	baseType := ""
	switch f.Type {
	case "string", "code", "id", "uri", "url":
		baseType = "string"
	case "integer", "positiveInt", "unsignedInt":
		baseType = "int"
	case "decimal":
		baseType = "decimal"
	case "boolean":
		baseType = "bool"
	case "date":
		baseType = "DateOnly"
	case "datetime", "instant":
		baseType = "DateTimeOffset"
	case "base64Binary":
		baseType = "byte[]"
	default:
		if strings.HasPrefix(f.Type, "[]") {
			innerType := strings.TrimPrefix(f.Type, "[]")
			inner := toCSharpType(schema.Field{Type: innerType, Required: true})
			baseType = fmt.Sprintf("List<%s>", inner)
		} else {
			baseType = "object"
		}
	}

	if !f.Required && baseType != "string" && baseType != "object" && !strings.HasPrefix(baseType, "List<") && baseType != "byte[]" {
		return baseType + "?"
	}
	return baseType
}
